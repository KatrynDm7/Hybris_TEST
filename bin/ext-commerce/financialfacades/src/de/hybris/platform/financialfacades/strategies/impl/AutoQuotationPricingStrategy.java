/*
 * [y] hybris Platform
 *
 * Copyright (c) 2000-2015 hybris AG
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of hybris
 * ("Confidential Information"). You shall not disclose such Confidential
 * Information and shall use it only in accordance with the terms of the
 * license agreement you entered into with hybris.
 *
 *
 */
package de.hybris.platform.financialfacades.strategies.impl;

import de.hybris.platform.commercefacades.quotation.QuotationItemRequestData;
import de.hybris.platform.commercefacades.quotation.QuotationItemResponseData;
import de.hybris.platform.commercefacades.quotation.QuotationRequestData;
import de.hybris.platform.financialfacades.constants.FinancialfacadesConstants;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.joda.time.LocalDate;
import org.joda.time.Years;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;


public class AutoQuotationPricingStrategy extends AbstractQuotationPricingStrategy
{
	/**
	 * Used to ensure that the date can be handled by Joda date library.
	 */
	protected static final String TZ_GMT = "GMT";

	/**
	 * Used to ensure that the date can be handled by Joda date library. Joda does not understand BST
	 */
	protected static final String TZ_BST = "BST";

	/**
	 * Used when parsing a string that has been generated by the standard Java Date toString method.
	 */
	protected static final String SYSTEM_TZ_FOR_STRING = "EEE MMM dd HH:mm:ss ZZZ yyyy";

	private static final Logger LOG = Logger.getLogger(AutoQuotationPricingStrategy.class);

	protected static final int BASE_FACTOR = 55;
	protected static final int MONTHLY_PRICE_FACTOR = 11;
	protected static final String LEGAL_EXPENSE = "AUTO_LEGAL_EXPENSE";
	protected static final String BREAK_DOWN = "AUTO_BREAKDOWN";
	protected static final String KEY_PROTECTION = "AUTO_KEY_PROTECTION";
	protected static final String FIVE_YEAR_GUARANTEE = "AUTO_5_YEAR";
	private static final String TERM_FREQUENCY = "termOfServiceFrequency";

	private Map<String, Double> formulaFactors;
	private String dateFormat;

	@Override
	public void initStrategy()
	{
		super.initStrategy();

		formulaFactors = new HashMap<String, Double>();

		//Age Factors
		formulaFactors.put("17-24", 2.0);
		formulaFactors.put("25-69", 1.0);
		formulaFactors.put("70+", 1.5);

		// Optional product factors
		formulaFactors.put(LEGAL_EXPENSE, 2.1);
		formulaFactors.put(BREAK_DOWN, 1.0);
		formulaFactors.put(KEY_PROTECTION, .87);
		formulaFactors.put(FIVE_YEAR_GUARANTEE, .59);
	}

	@Override
	protected List<QuotationItemResponseData> executeAlternativeAlgorithm(final QuotationRequestData quotationRequestData,
			final String basePrice)
	{
		final List<QuotationItemResponseData> productList = new ArrayList<QuotationItemResponseData>();
		QuotationItemResponseData productData;

		for (final QuotationItemRequestData itemData : quotationRequestData.getItems())
		{
			productData = new QuotationItemResponseData();

			// main product plan
			productData.setId(itemData.getId());
			final int divider = 29;

			Double value = 0.0;

			if (itemData.getId().indexOf(LEGAL_EXPENSE) != -1)
			{
				value = (Double.valueOf(basePrice) / divider) * formulaFactors.get(LEGAL_EXPENSE);
			}
			else if (itemData.getId().indexOf(BREAK_DOWN) != -1)
			{
				value = (Double.valueOf(basePrice) / divider) * formulaFactors.get(BREAK_DOWN);
			}
			else if (itemData.getId().indexOf(KEY_PROTECTION) != -1)
			{
				value = (Double.valueOf(basePrice) / divider) * formulaFactors.get(KEY_PROTECTION);
			}
			else if (itemData.getId().indexOf(FIVE_YEAR_GUARANTEE) != -1)
			{
				value = (Double.valueOf(basePrice) / divider) * formulaFactors.get(FIVE_YEAR_GUARANTEE);
			}

			value = (double) Math.round(value * 100) / 100;


			productData.setPayNowPrice(Double.toString(value));
			productData.setRecurringPrice(Double.toString(value));
			productList.add(productData);
		}

		return productList;
	}

	/**
	 * Method used to evaluate the QuotationRequestData.
	 *
	 * @param requestData
	 * @return true if it is valid request
	 */
	@Override
	protected boolean isValidQuote(final QuotationRequestData requestData)
	{
		boolean isValid = false;

		if (requestData.getProperties().get(FinancialfacadesConstants.AUTO_VEHICLE_VALUE) != null
				&& requestData.getProperties().get(FinancialfacadesConstants.AUTO_DRIVER_DOB) != null
				&& requestData.getItems() != null)
		{
			isValid = true;
		}

		return isValid;
	}

	/**
	 * Method which encapsulates the algorithm to calculate paynow price based on the static factors and the request
	 * data.
	 *
	 * @param requestData
	 * @param itemData
	 * @return final paynow price.
	 */
	@Override
	protected String executeAlgorithm(final QuotationRequestData requestData, final QuotationItemRequestData itemData)
	{
		// the formula : (valueOfVehicle/55) * ageRangeFactor
		double price = getVehicleValue(requestData) / BASE_FACTOR * getAgeFactor(requestData);

		price = (double) Math.round(price * 100) / 100;

		LOG.debug("Pay Now price for the given Data " + price);

		return Double.toString(price);
	}


	/**
	 * Helper method used to extract the driver's age calculation factor based on request data
	 *
	 * @param requestData
	 * @return age calculation factor
	 */
	protected double getAgeFactor(final QuotationRequestData requestData)
	{
		final String dobString = MapUtils.getString(requestData.getProperties(), FinancialfacadesConstants.AUTO_DRIVER_DOB,
				StringUtils.EMPTY);

		final LocalDate dobDate = buildLocalDate(dobString);

		final Years ageYears = Years.yearsBetween(dobDate, new LocalDate());
		final int age = ageYears.getYears();
		String ageRange = StringUtils.EMPTY;
		if (age >= 17 && age <= 24)
		{
			ageRange = "17-24";
		}
		else if (age >= 25 && age <= 69)
		{
			ageRange = "25-69";
		}
		else if (age >= 70)
		{
			ageRange = "70+";
		}

		return formulaFactors.get(ageRange);
	}

	/**
	 * @param dobString
	 * @return a LocalDate (joda date) from the DOB string
	 */
	protected LocalDate buildLocalDate(final String dobString)
	{
		LocalDate localDate = null;

		if (dobString != null)
		{
			try
			{
				final DateTimeFormatter dtf = DateTimeFormat.forPattern(getDateFormat());
				localDate = dtf.parseLocalDate(dobString);
			}
			catch (final IllegalArgumentException e)
			{
				try
				{
					final DateTimeFormatter sysdtf = DateTimeFormat.forPattern(SYSTEM_TZ_FOR_STRING);
					localDate = LocalDate.parse(dobString.replaceAll(TZ_BST, TZ_GMT), sysdtf);
				}
				catch (final IllegalArgumentException syse)
				{
					LOG.error("Unable to parse date : " + dobString, e);
				}

			}
		}

		if (localDate != null)
		{
			return localDate;
		}

		LOG.warn("null date for string : " + dobString);
		return new LocalDate();
	}

	protected double getVehicleValue(final QuotationRequestData requestData)
	{
		final double vehicleValue = MapUtils.getDoubleValue(requestData.getProperties(),
				FinancialfacadesConstants.AUTO_VEHICLE_VALUE);

		return vehicleValue;
	}

	@Override
	protected List<QuotationItemResponseData> populateQuotationProductData(final QuotationRequestData quotationRequestData)
	{
		final List<QuotationItemResponseData> productList = super.populateQuotationProductData(quotationRequestData);

		for (final QuotationItemResponseData quotationItemResponseData : productList)
		{
			final double monthlyPrice = calculateMonthlyPrice(quotationItemResponseData);

			quotationItemResponseData.setRecurringPrice(Double.toString(monthlyPrice));
		}

		return productList;
	}

	/**
	 * Helper method used to calculate monthly price baced on annual price value.
	 *
	 * @param quotationItemResponseData
	 * @return recurringPrice as double
	 */
	protected double calculateMonthlyPrice(final QuotationItemResponseData quotationItemResponseData)
	{
		double price = Double.parseDouble(quotationItemResponseData.getPayNowPrice()) / MONTHLY_PRICE_FACTOR;

		price = (double) Math.round(price * 100) / 100;

		return price;
	}

	/**
	 * @return the dateFormat
	 */
	public String getDateFormat()
	{
		return dateFormat;
	}

	/**
	 * @param dateFormat
	 *           the dateFormat to set
	 */
	public void setDateFormat(final String dateFormat)
	{
		this.dateFormat = dateFormat;
	}

}
